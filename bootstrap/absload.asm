L.CKSM	=	r0	; checksum
L.ADR 	=	r1
L.BC 	=	r2	; bytecount
L.BYT	=	r3	; byte
L.PTR	=	r5	; destination pointer

L.SR 	=	177570
L.DEV	=	DEVICE

LOAD	=	17400

	.ORG	LOAD+75
	.BYTE	75		; offset from LOAD
L.LOAD:	HALT

	.ORG	017500
L.LD1:	MOV	PC,SP
	CMP	-(SP),-(SP)
	MOV	PC,L.PTR
	ADD	$L.READ-.,L.PTR
	CLR	L.ADR
L.LD1B:	MOV	*$L.SR,*SP
	ROR	*SP
	BCS	L.LD1C
	CLR	*SP
	BR	L.LD2
L.LD1C:	ASL	*SP
	BNE	L.LD2
	MOV	L.ADR,*SP

	; LOOK FOR THE BEGINNING OF A BLOCK
L.LD2:	CLR	L.CKSM
	JSR	PC,*L.PTR	; READ A FRAME
	DECB	L.BYT		; CHECK FOR +1 (START OF BLOCK)
	BNE	L.LD2		; LOOP UNTIL +1 IS FOUND
	JSR	PC,*L.PTR	; READ ANOTHER FRAME
	JSR	PC,L.GWRD	; GET FULL BYTE COUNT
	MOV	R4,L.BC
	SUB	$4,L.BC		; SUBTRACT 4 TO MAKE BYTE COUNT CORRECT
	CMP	$2,L.BC		; WAS BYTE COUNT EQUAL TO 6?
	BEQ	L.JMP		; JUMP TO USER
	JSR	PC,L.GWRD	; GET LOAD ADDRESS
	ADD	*SP,R4		; GENERATE ACTUAL ADDRESS
	MOV	R4,L.ADR

	; READ REMAINDER OF DATA
L.LD3:	JSR	PC,*L.PTR
	BGE	L.LD4
	TSTB	L.CKSM
	BEQ	L.LD2
L.BAD:	HALT
	BR	L.LD2
L.LD4:	MOVB	L.BYT,(L.ADR)+
	BR	L.LD3

	; INPUT A FRAME, DECREMENT BYTE COUNT AND ACCUMULATE CHECKSUM
L.READ:	MOV	L.DEV,L.BYT
	INC	*L.BYT
L.R1:	TSTB	*L.BYT
	BPL	L.R1
	MOVB	2(L.BYT),L.BYT
	ADD	L.BYT,L.CKSM
	BIC	$177400,L.BYT	; MASK OFF JUNK
	DEC	L.BC
	RTS	PC

	; ASSEMBLE ONE FULL WORD OF DATA
L.GWRD:	MOV	(SP)+,L.TMP
	JSR	PC,*L.PTR
	MOV	L.BYT,R4
	JSR	PC,*L.PTR
	SWAB	L.BYT
	BIS	L.BYT,R4
	MOV	L.TMP,PC

	; CHECK CORRECTNESS OF JUMP ADDRESS
L.JMP:	JSR	PC,L.GWRD	; GET POSSIBLE TRANSFER ADDRESS
	JSR	PC,*L.PTR	; GET CHECKSUM
	TSTB	L.CKSM
	BNE	L.BAD
	ASR	R4
	BCC	L.JMP1
	HALT
	BR	L.LD1B
L.JMP1:	ASL	R4
	ADD	*SP,R4
	JMP	*R4		; JUMP TO USER
L.TMP:	.WORD	0		; TEMPORARY TO SAVE STACK SPACE

	; INITIALIZATION TO RESTORE THE BOOTSTRAP LOADER
	.ORG	LOAD+324
L.INIT:	MOV	$352,LOOP+2
	MOV	$765,BRNCH
	JMP	L.LOAD		; GO HALT AND WAIT FOR "CONT"
	NOP
	; THE FOLLOWING CODE OVERLAYS THE BOOTSTRAP LOADER
	.ORG	LOAD+344
START:	MOV	DEVICE,R1
LOOP:	MOV	(PC)+,R2
	.BYTE	BRNCH-LOAD-1
	.BYTE	-((BRNCH-L.INIT+2)/2)

	.ORG	LOAD+374
BRNCH:
	.ORG	LOAD+376
DEVICE:	

	.END
